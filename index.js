const stackTrace = require('stack-trace');
const fs = require('fs');
const ip = require('ip');
const ErrorReporting = require('@google-cloud/error-reporting').ErrorReporting;
const errors = new ErrorReporting();

function readLineFromFile (filePath, line){
	return new Promise((resolve, reject) => {
		var stream = fs.createReadStream(filePath, {
			flags: 'r',
			encoding: 'utf-8',
			fd: null,
			mode: '0666',
			bufferSize: 64 * 1024
		});

		var fileData = '';
		stream.on('data', function(data){
			fileData += data;

			var lines = fileData.split('\n');

			if(lines.length >= +line){
				stream.destroy();
				resolve(lines[+line]);
			} else {
				fileData = Array(lines.length).join('\n');
			}
		});

		stream.on('error', function(){
			reject(new Error('Error'));
		});

		stream.on('end', function(){
			reject(new Error('File end reached without finding line'));
		});
	});
};

async function processError ({service = 'node', version = 'latest', error}) {
	return new Promise(async (resolve, reject) => {
		const errorEvent = errors.event();

		errorEvent.serviceContext = {service, version};

		if (error.stack) {
			errorEvent._autoGeneratedStackTrace = error.stack;
		}

		errorEvent.setMessage(error.message || error);

		try {
			let firstCallSiteObject = stackTrace.parse(error).shift();
			errorEvent.context.reportLocation.filePath = firstCallSiteObject.fileName;
			errorEvent.context.reportLocation.lineNumber = firstCallSiteObject.lineNumber;
			errorEvent.context.reportLocation.functionName = firstCallSiteObject.functionName;

			let offendingLine = await readLineFromFile(errorEvent.context.reportLocation.filePath, errorEvent.context.reportLocation.lineNumber - 1);
			errorEvent.context.httpRequest.referrer = `${firstCallSiteObject.fileName}:${firstCallSiteObject.lineNumber}  "${offendingLine}"`;
		} catch (e) {}

		try {
			errorEvent.context.user = ip.address();
		} catch (e) {}

		errors.report(errorEvent, () => {
			resolve();
		});
	});
}


let isCatchingUncaughtErrors = false;
module.exports = ({service, version, catchUncaughtErrors}) => {
	if (catchUncaughtErrors && !isCatchingUncaughtErrors) {
		process
			.on('unhandledRejection', (error, p) => {
				console.error(error, 'gcp-report: Unhandled Rejection at Promise', p);
				processError({error, service, version}).then(() => {});
			})
			.on('uncaughtException', error => {
				console.error(error, 'gcp-report: Uncaught Exception thrown');
				processError({error, service, version}).then(() => {
					process.exit(1);
				})
			});

		isCatchingUncaughtErrors = true;
	}

	return error => {
		console.log(error.stack || error);
		return processError({error, service, version});
	}
};